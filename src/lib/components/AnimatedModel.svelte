<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 C:\Users\marti\Documents\GitHub\prstovka\static\models\Model.glb --root /models/ --types --printwidth 120 --precision 2
-->

<script lang="ts">
  import type * as THREE from 'three';
  import { Group } from 'three';
  import { type Events, forwardEventHandlers, type Props, type Slots, T } from '@threlte/core';
  import { useGltf, useGltfAnimations } from '@threlte/extras';

  import { Language } from '$lib/components/models/Word';

  type $$Props = Props<THREE.Group>
  type $$Events = Events<THREE.Group>
  type $$Slots = Slots<THREE.Group> & { fallback: {}; error: { error: any } }

  export const ref = new Group()

  type ActionName =
    | 'ActionLetterA'
    | 'ActionLetterAA'
    | 'ActionLetterAd'
    | 'ActionLetterB'
    | 'ActionLetterBB'
    | 'ActionLetterC'
    | 'ActionLetterCC'
    | 'ActionLetterCc'
    | 'ActionLetterCh'
    | 'ActionLetterChCh'
    | 'ActionLetterD'
    | 'ActionLetterDc'
    | 'ActionLetterDD'
    | 'ActionLetterE'
    | 'ActionLetterEc'
    | 'ActionLetterEd'
    | 'ActionLetterEE'
    | 'ActionLetterF'
    | 'ActionLetterFF'
    | 'ActionLetterG'
    | 'ActionLetterGG'
    | 'ActionLetterH'
    | 'ActionLetterHH'
    | 'ActionLetterI'
    | 'ActionLetterId'
    | 'ActionLetterII'
    | 'ActionLetterJ'
    | 'ActionLetterJJ'
    | 'ActionLetterK'
    | 'ActionLetterKK'
    | 'ActionLetterL'
    | 'ActionLetterLL'
    | 'ActionLetterM'
    | 'ActionLetterMM'
    | 'ActionLetterN'
    | 'ActionLetterNc'
    | 'ActionLetterNN'
    | 'ActionLetterO'
    | 'ActionLetterOd'
    | 'ActionLetterOO'
    | 'ActionLetterP'
    | 'ActionLetterPP'
    | 'ActionLetterQ'
    | 'ActionLetterQQ'
    | 'ActionLetterR'
    | 'ActionLetterRc'
    | 'ActionLetterRR'
    | 'ActionLetterS'
    | 'ActionLetterSc'
    | 'ActionLetterSS'
    | 'ActionLetterT'
    | 'ActionLetterTc'
    | 'ActionLetterTT'
    | 'ActionLetterU'
    | 'ActionLetterUd'
    | 'ActionLetterUU'
    | 'ActionLetterV'
    | 'ActionLetterVV'
    | 'ActionLetterW'
    | 'ActionLetterWW'
    | 'ActionLetterX'
    | 'ActionLetterXX'
    | 'ActionLetterY'
    | 'ActionLetterYd'
    | 'ActionLetterYY'
    | 'ActionLetterZ'
    | 'ActionLetterZc'
    | 'ActionLetterZZ'
    | 'ActionRest'
    | 'ActionRestToTransition'
    | 'PoseFive'
    | 'PoseLetterA'
    | 'PoseLetterB'
    | 'PoseLetterC'
    | 'PoseLetterCH'
    | 'PoseLetterD'
    | 'PoseLetterE'
    | 'PoseLetterF'
    | 'PoseLetterG'
    | 'PoseLetterH'
    | 'PoseLetterI'
    | 'PoseLetterJ'
    | 'PoseLetterK'
    | 'PoseLetterL'
    | 'PoseLetterM'
    | 'PoseLetterN'
    | 'PoseLetterO'
    | 'PoseLetterP'
    | 'PoseLetterQ'
    | 'PoseLetterR'
    | 'PoseLetterS'
    | 'PoseLetterT'
    | 'PoseLetterU'
    | 'PoseLetterV'
    | 'PoseLetterW'
    | 'PoseLetterX'
    | 'PoseLetterY'
    | 'PoseLetterZ'
    | 'PoseNumber5'
    | 'PosePositionRest'
    | 'PosePositionTransition'
    | 'KeyAction'
  type GLTFResult = {
    nodes: {
      Ch22_Hair: THREE.SkinnedMesh
      Ch22_Pants: THREE.SkinnedMesh
      Ch22_Shirt: THREE.SkinnedMesh
      Ch22_Sneakers: THREE.SkinnedMesh
      Ch22_Body: THREE.SkinnedMesh
      mixamorig2Hips: THREE.Bone
    }
    materials: {
      Ch22_hair: THREE.MeshStandardMaterial
      Ch22_body: THREE.MeshStandardMaterial
    }
  }

  export const gltf = useGltf<GLTFResult>('/models/Model.glb', {
    useDraco: true
  })
  export const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref)

  const component = forwardEventHandlers()

  // USER DEFINED CODE ----------------------

  //Change action offset for different types of animations e.g. CZ2 for Two hand czech alphabet
  //This purely depends on the naming convention of given animated model
  let actionOffset = "ActionLetter";

  export let isPaused : boolean = false;
  export let letterDisplay : string = "-"; //Letter in string for display purposes

  let text = "";  //Text to be animated
  let currentChar = '';
  let previousChar = '';

  export let transitioning : boolean = false;

  let speed = 1;
  let delayOnNewWord = 1000 / speed;
  let delayOnNewLetter = 300 / speed;
  let transitionSpeed = Math.min(1, Math.pow(speed, -1));

  let currentActionKey = 'ActionRest' //Default action = rest

  const dict: { [key: string]: string } = {
    "Á": "Ad",
    "É": "Ed",
    "Í": "Id",
    "Ó": "Od",
    "Ú": "Ud",
    "Ů": "Ud", // Missing animation for "Ů" so use "Ú" instead
    "Ý": "Yd",
    "Č": "Cc",
    "Ď": "Dc",
    "Ě": "Ec",
    "Ň": "Nc",
    "Ř": "Rc",
    "Š": "Sc",
    "Ť": "Tc",
    "Ž": "Zc"
  }

  function normalizeActionKey(letter : string, double : boolean) : string{
    let charToReturn : string = letter;
    if (letter in dict){
      return dict[letter]; // Don't return doubled special letter -> no animations for them
    }

    if(double){
      return charToReturn + charToReturn
    }

    return charToReturn;
  }

  function transitionTo (nextActionKey: string, duration = 1){
    transitioning = true;

    console.log("transitionTo", nextActionKey)
    const currentAction = $actions[currentActionKey as ActionName]
    const nextAction = $actions[nextActionKey as ActionName]

    if(nextAction && nextActionKey.includes("Letter")){

      nextAction.setLoop(2200, 1); // 2200 - LoopOnce
      nextAction.clampWhenFinished = true;
      nextAction.reset();
    }

    if (!nextAction || currentAction === nextAction) {
      return;
    }

    // Function inspired by: https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_skinning_blending.html
    nextAction.enabled = true
    if (currentAction) {
      currentAction.crossFadeTo(nextAction, duration, true)
    }

    currentActionKey = nextActionKey
  }

  mixer.addEventListener("finished", () => {
    transitioning = false;

    if(currentActionKey.includes("Letter")){
      setTimeout(() => {
        playAnimationRec()
      }, delayOnNewLetter);
    }
  });

  //When currentActionKey changes, play the animation
  $: $actions[currentActionKey as ActionName]?.play()

  function playAnimationRec(){
    if(text.length == 0) {
      //End of animation
      letterDisplay = "-";
      transitionTo("ActionRest", 0.6)
      transitioning = false; // because rest doesn't stop
      return;
    }

    if(currentChar.toLowerCase() != currentChar.toUpperCase()){
      previousChar = currentChar; //Change previous char only if the current previous is letter
    }

    currentChar = text.charAt(0);

    //Special case for letter "CH"
    if(currentChar == 'C' && text.length > 1 && text.charAt(1) == "H")
    {
      currentChar = "Ch";
      text = text.substring(1);
    }

    text = text.substring(1);

    if(currentChar.toLowerCase() != currentChar.toUpperCase()){
      // if char is letter
      letterDisplay = currentChar;
      transitionTo(actionOffset + normalizeActionKey(currentChar, currentChar === previousChar), transitionSpeed);
    }
    else{
      //delay on new word
      return setTimeout(() => { playAnimationRec() }, delayOnNewWord);
    }
  }

  export function playAnimationForText(textArg : string, language : Language){

    if(language === Language.CzechFingerOneHand){
      actionOffset = "ActionLetter";
    }
    else if(language == Language.CzechFingerTwoHand){
      actionOffset = "CZ2ActionLetter";
    }
    else{
      //TODO
      actionOffset = "ActionLetter";
    }

    text = textArg.toUpperCase();
    currentChar = '';
    previousChar = '';

    playAnimationRec();
  }

  // sets delay based on speed
  export function changeSpeed(newSpeed : number){
    speed = newSpeed;
    console.log("Speed changed to: ", speed);

    if(!isPaused)
      mixer.timeScale = speed;
    delayOnNewLetter = 300 / speed;
    delayOnNewWord = 1000 / speed;
    transitionSpeed = Math.min(1, Math.pow(speed, -1))

    console.log("mixer.timeScale: ", mixer.timeScale);
    console.log("Delay on new letter: ", delayOnNewLetter);
    console.log("Delay on new word: ", delayOnNewWord);
    console.log("Transition speed: ", transitionSpeed);
  }

  export function resetAnimation(){
    transitionTo('ActionRest', 0.5);
    currentChar = '';
    previousChar = '';
    text = '';
    letterDisplay = '-';
  }

  export function pauseAnimation(){
    mixer.timeScale = 0;
    isPaused = true;
  }

  export function resumeAnimation(){
    mixer.timeScale = speed;
    isPaused = false;
  }

  export function pauseResumeAnimation(){
    if(isPaused){
      resumeAnimation();
    }
    else{
      pauseAnimation();
    }
  }

  //TODO, delete this, toggle between language only by passing arg to playAnimation
  export function toggleLanguageMode(){
    if(actionOffset === "ActionLetter"){
      actionOffset = "CZ2ActionLetter";
    }
    else{
      actionOffset = "ActionLetter";
    }
  }
</script>

<svelte:options accessors/>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component} position = {[0, -1.5, 0]}>
  {#await gltf}
    <slot name="fallback" />
  {:then gltf}
    <T.Group name="Scene">
      <T.Group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <T is={gltf.nodes.mixamorig2Hips} />
        <T.SkinnedMesh
          name="Ch22_Hair"
          geometry={gltf.nodes.Ch22_Hair.geometry}
          material={gltf.materials.Ch22_hair}
          skeleton={gltf.nodes.Ch22_Hair.skeleton}
        />
        <T.SkinnedMesh
          name="Ch22_Pants"
          geometry={gltf.nodes.Ch22_Pants.geometry}
          material={gltf.materials.Ch22_body}
          skeleton={gltf.nodes.Ch22_Pants.skeleton}
        />
        <T.SkinnedMesh
          name="Ch22_Shirt"
          geometry={gltf.nodes.Ch22_Shirt.geometry}
          material={gltf.materials.Ch22_body}
          skeleton={gltf.nodes.Ch22_Shirt.skeleton}
        />
        <T.SkinnedMesh
          name="Ch22_Sneakers"
          geometry={gltf.nodes.Ch22_Sneakers.geometry}
          material={gltf.materials.Ch22_body}
          skeleton={gltf.nodes.Ch22_Sneakers.skeleton}
        />
        <T.SkinnedMesh
          name="Ch22_Body"
          geometry={gltf.nodes.Ch22_Body.geometry}
          material={gltf.materials.Ch22_body}
          skeleton={gltf.nodes.Ch22_Body.skeleton}
          morphTargetDictionary={gltf.nodes.Ch22_Body.morphTargetDictionary}
          morphTargetInfluences={gltf.nodes.Ch22_Body.morphTargetInfluences}
        />
      </T.Group>
    </T.Group>
  {:catch error}
    <slot name="error" {error} />
  {/await}

  <slot {ref} />
</T>
