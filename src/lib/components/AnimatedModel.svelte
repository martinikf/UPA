<svelte:options accessors />

<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.3 path\Model.glb --root /models/ --types --printwidth 120 --precision 2
-->

<script lang="ts">
	/**
	 * 3D animated model component, autogenerated from glb, with additional functions
	 *
	 * Svelte component that plays and controls 3D animation of character
	 * based on three.js uses gltf (glb) models and draco compression
	 * - Smooth transitioning between animations
	 * - Animation speed control and customizable delays
	 * - Optional character display of current animation
	 * - Support for multiple languages
	 *
	 * API:
	 * - provides 'playAnimationForText(text: string, language: Language)' function
	 *            to play animation for given text
	 * - provides 'changeSpeed(speed: number)' function to change animation speed linearly
	 *            1 - default speed
	 * - provides 'resetAnimation()' function to reset animation to default state
	 * - provides 'pauseAnimation()' function to pause animation
	 * - provides 'resumeAnimation()' function to resume animation
	 * - provides 'pauseResumeAnimation()' function to toggle between pause/resume animation
	 * - provides 'letterDisplay' variable to display current letter in animation
	 */

	// Import required dependencies for 3D rendering and animation
	import type * as THREE from 'three';
	import { Group } from 'three';
	import { type Events, forwardEventHandlers, type Props, type Slots, T } from '@threlte/core';
	import { useGltf, useGltfAnimations } from '@threlte/extras';

	// Import custom types and enums
	import type { ActionName, GLTFResult } from '$lib/models/AnimationTypes';
	import { Language } from '$lib/models/Word';
	import { ActionOffset } from '$lib/models/ActionOffset';

	type $$Props = Props<THREE.Group>;
	type $$Events = Events<THREE.Group>;
	type $$Slots = Slots<THREE.Group> & { fallback: {}; error: { error: any } };

	// Initialize 3D group and load GLTF model with Draco compression
	const ref = new Group();
	const gltf = useGltf<GLTFResult>('/models/Model.glb', {
		useDraco: true
	});
	const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref);
	const component = forwardEventHandlers();

	/** Variable to display current letter in animation */
	export let letterDisplay: string = '-';

	/** ActionName of currently playing animation, this offset is set from outside language argument */
	let actionOffset: ActionOffset = ActionOffset.ActionLetter;

	/** Holder for rest animation ActionName */
	const restAction: ActionName = 'ActionRest';
	let currentActionName: ActionName = restAction; //Default action = rest

	// Internal state variables
	/** Stores the text to be animated, gets shortened with the animation progress */
	let text: string = '';
	let currentChar: string = '';
	let previousChar: string = '';
	let isPaused: boolean = false;

	// Word animations
	let sentence: string = '';

	// Animation timing variables
	let speed: number = 1;
	let delayOnNewWord: number = 1000 / speed;
	let delayOnNewLetter: number = 300 / speed;
	let transitionSpeed: number = Math.min(1, Math.pow(speed, -1));

	/**
	 * Dictionary for mapping special characters to their one-hand animation names
	 */
	const dictActionLetter: { [key: string]: string } = {
		Á: 'Ad',
		É: 'Ed',
		Í: 'Id',
		Ó: 'Od',
		Ú: 'Ud',
		Ů: 'Ud', // Missing animation for "Ů" so use "Ú" instead
		Ý: 'Yd',
		Č: 'Cc',
		Ď: 'Dc',
		Ě: 'Ec',
		Ň: 'Nc',
		Ř: 'Rc',
		Š: 'Sc',
		Ť: 'Tc',
		Ž: 'Zc'
	};

	/**
	 * Dictionary for mapping special characters to their two-hand animation names
	 */
	const dictCZ2ActionLetter: { [key: string]: string } = {
		Á: 'A',
		É: 'E',
		Í: 'I',
		Ó: 'O',
		Ú: 'U',
		Ů: 'U',
		Ý: 'Y',
		Č: 'C',
		Ď: 'D',
		Ě: 'E',
		Ň: 'N',
		Ř: 'R',
		Š: 'S',
		Ť: 'T',
		Ž: 'Z'
	};

	const animatedWords = ["Ahoj", "Mama"];

	// Reactive statement to play animation when currentActionName changes
	$: $actions[currentActionName]?.play();

	// Event listener for animation end
	// If the ended animation was for a letter, call playAnimationRec for the possible next letter
	mixer.addEventListener('finished', () => {
		if (currentActionName.includes('Letter')) {
			setTimeout(() => {
				playAnimationRec();
			}, delayOnNewLetter);
		}
		else if(currentActionName.includes('Word')){
			setTimeout(() => {
				playSentenceRec();
			}, delayOnNewWord);
		}
	});

	/**
	 * Determines the action offset based on the language
	 * @param lang Language enum value
	 * @returns Appropriate ActionOffset for the language
	 */
	function getActionOffset(lang: Language): ActionOffset {
		switch (lang) {
			case Language.CzechFingerOneHand:
				return ActionOffset.ActionLetter;
			case Language.CzechFingerTwoHand:
				return ActionOffset.CZ2ActionLetter;
			default:
				return ActionOffset.ActionLetter;
		}
	}

	/**
	 * Normalizes a character to its corresponding animation key
	 * @param letter Character to normalize
	 * @param double Whether to double the character (for immediately repeated letters)
	 * @returns Normalized animation key
	 */
	function normalizeActionKey(letter: string, double: boolean): string {
		// NOTE: Only ActionLetter (cz one hand) have animations for special letters and double letters
		// Handle special characters based on current action offset
		if (actionOffset == ActionOffset.ActionLetter && letter in dictActionLetter) {
			return dictActionLetter[letter];
		} else if (actionOffset == ActionOffset.CZ2ActionLetter && letter in dictCZ2ActionLetter) {
			return dictCZ2ActionLetter[letter];
		}

		// Double letters only supported in one-hand animations
		if (double && actionOffset == ActionOffset.ActionLetter) {
			return letter + letter;
		}

		return letter;
	}

	/**
	 * Handles transition between animations
	 * @param nextActionName Next animation to transition to
	 * @param duration Duration of the transition
	 */
	function transitionTo(nextActionName: ActionName, duration = 1) {
		const currentAction = $actions[currentActionName as ActionName];
		const nextAction = $actions[nextActionName as ActionName];

		// Configure the animation
		if (nextAction && (nextActionName.includes('Letter') || nextActionName.includes('Word'))) {
			nextAction.setLoop(2200, 1); // 2200 - LoopOnce
			nextAction.clampWhenFinished = true;
			nextAction.reset();
		}

		// Nothing to transition to
		if (!nextAction || currentAction === nextAction) {
			return;
		}

		// Perform the transition
		// Function inspired by: https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_skinning_blending.html
		nextAction.enabled = true;
		if (currentAction) {
			currentAction.crossFadeTo(nextAction, duration, true);
		}

		// Replace current action with next action (the one playing now)
		currentActionName = nextActionName;
	}

	/**
	 * Recursive function to play animations for each character
	 */
	function playAnimationRec() {
		// Check if animation sequence is complete
		if (text.length == 0) {
			if(sentence.length > 0){
				playSentenceRec();
			}
			else {
				letterDisplay = '-';
				transitionTo(restAction, 0.6);
			}
			return;
		}

		// Update previous character if current is a letter
		if (currentChar.toLowerCase() != currentChar.toUpperCase()) {
			previousChar = currentChar;
		}
		// Set the currentChar to the first char of the text
		currentChar = text.charAt(0);

		// Special case for letter "Ch"
		if (currentChar == 'C' && text.length > 1 && text.charAt(1) == 'H') {
			currentChar = 'Ch';
			text = text.substring(1);
		}

		//Forget first char from text
		text = text.substring(1);

		// Handle letters vs non-letters
		if (currentChar.toLowerCase() != currentChar.toUpperCase()) {
			// If char is a letter
			letterDisplay = currentChar;
			transitionTo(
				(actionOffset.toString() +
					normalizeActionKey(currentChar, currentChar === previousChar)) as ActionName,
				transitionSpeed
			);
		} else {
			// Space or other non-letter character
			// Assume that it is a space for a new word
			return setTimeout(() => {
				playAnimationRec();
			}, delayOnNewWord);
		}
	}

	function playSentenceRec() {
		console.log(sentence)

		const actionOffset = "ActionWord"

		const trimmed = sentence.trim();
		const words = trimmed.split(/\s+/);
		const firstWord = words.shift() || null;
		if (firstWord === null) {
			transitionTo(restAction, 0.6);
			return;
		}
		const lower = firstWord.toLowerCase();
		const transformedWord = lower.charAt(0).toUpperCase() + lower.slice(1);

		sentence = sentence.trim().slice(firstWord.length);

		if (animatedWords.includes(transformedWord)) {
			transitionTo((actionOffset.toString() + transformedWord) as ActionName, transitionSpeed)
		}
		else{
			// play finger alphabet for that world
			playAnimationForText(transformedWord, Language.CzechFingerOneHand);
		}
	}

	/**
	 * Initiates animation for given text in specified language
	 */
	export function playAnimationForText(textArg: string, language: Language) {
		actionOffset = getActionOffset(language);

		if (language == Language.Czech) {
			// Handle sign language differently to finger alphabet
			sentence = textArg;
			playSentenceRec()
		}
		else {

			text = textArg.trim().toUpperCase();
			currentChar = '';
			previousChar = '';

			playAnimationRec();
		}
	}

	/**
	 * Updates animation speed and related timing parameters
	 *
	 * @param newSpeed New speed value to set
	 */
	export function changeSpeed(newSpeed: number) {
		if (newSpeed < 0 || newSpeed > 10) {
			return;
		}

		speed = newSpeed;

		if (!isPaused) mixer.timeScale = speed;
		delayOnNewLetter = 300 / speed;
		delayOnNewWord = 1000 / speed;
		transitionSpeed = Math.min(1, Math.pow(speed, -1));
	}

	/**
	 * Resets animation to initial state
	 */
	export function resetAnimation() {
		transitionTo(restAction, 0.5);
		currentChar = '';
		previousChar = '';
		text = '';
		letterDisplay = '-';
	}

	/**
	 * Pauses the animation
	 */
	export function pauseAnimation() {
		mixer.timeScale = 0;
		isPaused = true;
	}

	/**
	 * Resumes the animation
	 */
	export function resumeAnimation() {
		mixer.timeScale = speed;
		isPaused = false;
	}

	/**
	 * Toggles between pause and resume states
	 */
	export function pauseResumeAnimation() {
		if (isPaused) {
			resumeAnimation();
		} else {
			pauseAnimation();
		}
	}
</script>

<!-- Main 3D component render -->
<T is={ref} dispose={false} {...$$restProps} bind:this={$component} position={[0, -1.5, 0]}>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<T.Group name="Scene">
			<T.Group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
				<T is={gltf.nodes.mixamorig2Hips} />
				<T.SkinnedMesh
					name="Ch22_Hair"
					geometry={gltf.nodes.Ch22_Hair.geometry}
					material={gltf.materials.Ch22_hair}
					skeleton={gltf.nodes.Ch22_Hair.skeleton}
				/>
				<T.SkinnedMesh
					name="Ch22_Pants"
					geometry={gltf.nodes.Ch22_Pants.geometry}
					material={gltf.materials.Ch22_body}
					skeleton={gltf.nodes.Ch22_Pants.skeleton}
				/>
				<T.SkinnedMesh
					name="Ch22_Shirt"
					geometry={gltf.nodes.Ch22_Shirt.geometry}
					material={gltf.materials.Ch22_body}
					skeleton={gltf.nodes.Ch22_Shirt.skeleton}
				/>
				<T.SkinnedMesh
					name="Ch22_Sneakers"
					geometry={gltf.nodes.Ch22_Sneakers.geometry}
					material={gltf.materials.Ch22_body}
					skeleton={gltf.nodes.Ch22_Sneakers.skeleton}
				/>
				<T.SkinnedMesh
					name="Ch22_Body"
					geometry={gltf.nodes.Ch22_Body.geometry}
					material={gltf.materials.Ch22_body}
					skeleton={gltf.nodes.Ch22_Body.skeleton}
					morphTargetDictionary={gltf.nodes.Ch22_Body.morphTargetDictionary}
					morphTargetInfluences={gltf.nodes.Ch22_Body.morphTargetInfluences}
				/>
			</T.Group>
		</T.Group>
	{:catch error}
		<slot name="error" {error} />
	{/await}

	<slot {ref} />
</T>
